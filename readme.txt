Директория содержит файлы для лабораторных работ по распределённым системам.

Цель: дать студентам (пользователям) небольшую инфраструктуру, позволяющую создавать модели распределённых процессов.

Требования:
Максимальная простота вхождения (требуется написать минимум кода и исправлять/дописывать минимальное количество файлов)
Моделирование распределённых процессов, обменивающихся сообщениями.
Моделирование синхронного режима работы (процессы, получившие сообщения в течении такта 
  синхронизации отправляют сообщения другим процессам, которые получают их в начале следующего такта.
Моделирование асинхронного режима работы (каждое сообщение доставляется процессу в течение времени, определённого весом связи 
  между процессами).
Моделирование потерь сообщений. Параметр errorRate (0 <= errorRate <= 1) определяет вероятность потери сообщения. 
Робастные алгоритмы должны быть относительно устойчивы к потерям сообщений.

Типы алгоритмов для моделирования:
Топологические алгоритмы. 
  Построение остовных деревьев.
  Определение достижимости узла.
  Определение кратчайшего пути.
  
Алгоритмы выборов
Алгоритмы синхронизации
Алгоритмы определения завершения
Алгоритмы упорядоченной рассылки
.....


---------------

Как это реализуется:
Вся модель реализована на языке C++.

Имеются несколько простых классов (наследование не применяется) для реализации общих функций.
Они находятся в одном файле DSSimul.h. Файлы компилируются в операционных системах 
Windows, OS X и linux, но не содержат функции main(). Цель лабораторной работы - написать
подходящий main() и функцию-обработчих сообщений (об этом далее). Пример приведён в проекте.

Главный класс проекта - мир, World. Он создаёт модели распределённых процессов (далее - просто процессы),
регистрирует (register) функции-обработчики (общие для всех процессов системы) и назначает обработчик для
конкретного процесса (assign). 

Класс NetworkLayer отвечает за связи между процессами и доставку сообщений между процессами.
В одном мире может быть несколько сетей и каждый процесс может принадлежать нескольким сетям.
Он моделирует асинхронный и синхронный режимы посылки сообщений между процессами а также 
может привносить ошибки в передачу (например, сообщение может быть потеряно с некоторой вероятностью).

Класс DistributedProcess моделирует сам распределённый процесс. Каждый процесс должен зарегистрироваться
в своей сети для того, чтобы известить сеть о своём появлении. Сеть теперь знает, куда посылать
сообщения, предназначенные для данного процесса. Для пробуждения процесса про получании сообщения используется класс Event.
Ведётся две очереди сообщений - входящая и рабочая. 
Запускается два исполнительных потока - receiveThread и workerThread. 
Первый из этих потоков обнаруживает появление сообщений во входящей очереди и если
сообщение требует обработки перекладывает её в рабочую. 
Рабочий процесс анализирует по сообщению, какой функции-обработчику
предназначено сообщение и вызывает сообветствующий обработчик. 

Названия остальных классов говорят сами за себя: Error, Exception, Thread, Mutex, Event, Message, MessageQueue.

Немного подробнее о рабочей функции.
Она вызывается с двумя аргументами. Первый - контекст класса DistributedProcess, который
даёт возможность определить топологию сети (непосредственных соседей) и свой номер.
Пользователь может добавить в класс DistributedProcess свой контекст, который будет использовать рабочая функция. 
Для этого требуется:
1) описать свою структуру или класс, поместить это описание в отдельный заголовочный файл или добавить описание в файл contextes.h (см. пример в файле).
2) описать объект этого типа с уникальным именем (см. там же)
3) добавить соответствующий #include в файл contextes.h (если нужно)

Этот контекст будет включён в общий контекст класса DistributedProcess и может быть использован как самой рабочей функцией, 
так и любыми другими (это позволяет, например, в одной рабочей функции определить список всех доступных процессов, не только соседей, 
а в другой рабочей функции посылать этим процессам сообщения.

Рабоча функция должна проверять сообщение, возвращать истину, если она готова и может обработать это сообщение и ложь, 
если она не может его обработать (например, если сообщение предназначено другой рабочей функции)


Топология сети описается в файле config.data
Его команды:
processes 1 11
	создать процессы от 1 до 11

link from 1 to 2 [latency 10]

link from 1 to all [latency 5]

link from all to all [latency 1]

setprocesses 2 5 TEST

send from 4 to 10 TEST_BEGIN 1

send from -1 to 1 TEST_BEGIN

wait all

Для примера имеется готовая рабочая функкция TEST

Для компиляции под Windows Visual Studio имеется проект DSSimul.vcxproj

В других ОС компилировать только файл main.cpp. Имеется соответствующий Makefile.

Используется стандарт языка C++11, он поддерживается начиная с g++ 4.9, Visual C++ 2013, clang++ 3.3




